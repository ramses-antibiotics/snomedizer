---
title: "Mapping SNOMED CT concepts from free text"
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
    fig_caption: yes
    df_print: tibble
vignette: >
  %\VignetteIndexEntry{Mapping SNOMED CT concepts from free text}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(snomedizer)
data("drug_indications")
```


# Introduction

Analysing electronic health records often requires processing free-text data generated by clinicians' interactions with a variety of clinical systems. Manually classifying and coding free-text data on a large scale is impractical. 

In those cases, SNOMED CT can help in several ways:

1. identifying clinical concepts within the free text, using SNOMED CT's list of known synonyms (or 'descriptions') for a given concept. For instance, `78048006` is has multiple descriptions: `Candidiasis` (preferred term); `Candidosis`; `Candida infection`; `Moniliasis`; `Monilia infection`; and `Thrush`
2. reclassifying clinical concepts into broader ('parent') concepts (eg `40600002 | Pneumococcal bronchitis (disorder) |` is a `275498002 | Respiratory tract infection (disorder) |`)
3. extracting stated/inferred attributes from the SNOMED CT ontology (eg the pathogen causing `40600002 | Pneumococcal bronchitis (disorder) |` is `9861002 | Streptococcus pneumoniae (organism) |`)

A handy introduction to the SNOMED CT terminology can be found in the <a href="http://snomed.org/sg" target="_blank">SNOMED CT Starter Guide</a>, particularly chapters [5. SNOMED CT Logical Model](http://snomed.org/sg/5.+SNOMED+CT+Logical+Model) and [6. SNOMED CT Concept Model](http://snomed.org/sg/6.+SNOMED+CT+Concept+Model).

This vignette demonstrates a simple workflow to extract SNOMED CT concepts from free-text information and use the full SNOMED CT ontology to reclassify these concepts into higher-level ones.

# Motivating example

Hospitals commonly need to carry out clinical audits of antibiotic prescribing. This involves measuring what antibiotics are prescribed for, and whether the dose/duration of prescriptions is suitable. Many clinical systems record prescription indications as free-text data.

For this, the prescription indication must be extracted and grouped into categories. We examine an example dataset named `drug_indications` from a hospital electronic prescription system, containing free-text indications for `r nrow(drug_indications)` prescriptions.

```{r glimpse_indications}
library(snomedizer)
str(drug_indications)
```


In this example, we aim to identify the proportion of prescribing by type of infection.


# Setup

We rely on several packages from the [`tidyverse`](https://www.tidyverse.org/learn/) to help manipulate structured data as well as string data (free-text).

```{r load_packages, message=FALSE, warning=FALSE}
library(dplyr)     # relational data wrangling package 
library(tidyr)     # tidy data
library(stringr)   # to manipulate strings (free-text data) 
library(tidytext)  # to manipulate strings (free-text data)
library(stopwords) # lists common and uncharacteristics words to discard
# library(magrittr)  # loads the pipe (`%>%`) operator


```

We connect to the July 2021 release branch on the official IHTSDO Snowstorm server.

```{r setup_snowstorm_server, eval = FALSE}
# Public SNOMED CT terminology server and branch
sct_server <- "https://snowstorm.ihtsdotools.org/snowstorm/snomed-ct"
sct_branch <- "MAIN/2021-07-31"

# Verify that the server connection is working
snomed_endpoint_test(sct_server, sct_branch)
#> [1] TRUE

snomedizer_options_set(endpoint = sct_server, 
                       branch = sct_branch, 
                       limit = 10000)
```

<div class="bd-callout bd-callout-warning">
<h4>SNOMED CT Licence</h4>
<p>This vignette uses SNOMED CT data under the <emph>SNOMED CT Browser License Agreement</emph>.</p>
<p>Terms and conditions can be found on <code>help("snomedizer")</code>.</p>
</div>


## Fetch concepts and descriptions

The first step is to fetch all SNOMED CT concepts that are relevant to the analysis. This vignette about antibiotic prescriptions is primarily interested in infectious diseases. The concepts of interest descend from the following SNOMED CT concepts, either through stated or inferred relationships:

- `40733004 | Infectious disease (disorder) |`  
- `473130003 | Suspected infectious disease (situation) |`, for syndromes that have yet to be diagnosed
- additional syndromes that are believed to be infections, but not explicitly recorded as such. For example, doctors will commonly use the concept <code>233604007 | Pneumonia (disorder) |</code> in notes and prescribe an antibacterial. In this instance we can infer they imply <code>312342009 | Infective pneumonia (disorder) |</code> or even <code>53084003 | Bacterial pneumonia (disorder) |</code>, which unlike <code>233604007</code> are descendants of  <code>40733004 | Infectious disease (disorder) | </code>


<div class="bd-callout bd-callout-info">

<h4>Note</h4>

<p>Antibiotics can also be prescribed for:</p>
<ul>
<li><strong>medical prophylaxis</strong>, to prevent a urinary tract infection. This procedure can be described with a more complex <i>postcoordinated</i> SNOMED CT expression:

<pre><code>281789004 |Antibiotic therapy (procedure)|:
{ 363703001 |Has intent (attribute)| = 360271000 |Prophylaxis - procedure intent (qualifier value)|,
  363702006 |Has focus (attribute)|  = 68566005 |Urinary tract infectious disease (disorder)| }</code></pre>
  
</li>
<li><strong>surgical prophylaxis</strong>, to prevent a surgical site infection that could occur as part of a <code>362958002 | Procedure by site (procedure) |</code>, for instance:

<pre><code>281789004 |Antibiotic therapy (procedure)|: 
{ 363703001 |Has intent (attribute)| = 360271000 |Prophylaxis - procedure intent (qualifier value)|,  
  363702006 |Has focus (attribute)|  = 179750003 | Incision of soft tissue of hand (procedure) | }</code></pre>

</li>
</ul>

<p>This contrasts with infection treatment, where 
<pre><code>363703001 |Has intent (attribute)| = 373808002 | Curative - procedure intent (qualifier value) |</code></pre>
</p>
<p>For simplicity, we ignore prophylactic use or SNOMED CT expressions in this vignette.</p>
<p>You can learn more about postcoordinated SNOMED CT expressions in the <a href="https://confluence.ihtsdotools.org/display/DOCSTART/7.+SNOMED+CT+Expressions">SNOMED CT Starter Guide (chapter 7)</a>.</p>

</div>




 


We query the terminology server in two steps: (1) we retrieve and combine descendants of the three concepts cited above using <code>dplyr::bind_rows()</code>, then (2) retrieve descriptions of each of these concepts:

```{r fetch_infection_concepts_DONTRUN, eval=FALSE, include=TRUE}
# (1) Fetch all concepts descending from 40733004, 128045006, or 128477000
abx_indications_concepts <- concepts_descendants(
  conceptIds = c("40733004 | Infectious disease (disorder) |",
                 "128045006 | Cellulitis (disorder) |",
                 "128477000 | Abscess (disorder) |")
) %>%
  bind_rows() %>%
  unique()
#> |========================================================|100% ~0 s remaining

# (2) Fetch all descriptions for these concepts
abx_indications_concepts$descriptions <- concepts_descriptions(
  conceptIds = abx_indications_concepts$conceptId)
#> |========================================================|100% ~0 s remaining
```


As most users will not have access to such a server, the output of the code chunk presented above can be found in the `infection_concepts` dataset included in `snomedizer`. As can be seen below, `infection_concepts` contains a total of `r nrow(infection_concepts)` concepts.

```{r fetch_infection_concepts_RUN}
# data("infection_concepts")
# str(infection_concepts, max.level	= 1)
```

The `descriptions` variable is a list of nested data frames consisting of a minimum of 2 description records per concept: 1 fully specified name, and at least 1 (preferred) synonym. Some concepts will have more synonyms.

```{r head_infection_description1}
# infection_concepts$descriptions[[10]] %>% 
#   select(conceptId, descriptionId, term, type, acceptabilityMap.900000000000509007)
```


## Processing SNOMED CT concept description strings

To make use of concept descriptions, we need to isolate and stardardise words making up the terminology. Only active synonyms are used (fully specified names being redundant). After trimming punctuation, synonym descriptions are converted to lowercase and **'tokenised'**, meaning individual words (or 'tokens') are separated into a vector.

```{r}
# infection_descriptions <- infection_concepts$descriptions %>%
#   dplyr::bind_rows() %>%
#   dplyr::filter(active, type != "FSN") %>%
#   dplyr::transmute(
#     conceptId,
#     descriptionId,
#     descriptionText = term,
#     tokens_concept = stringr::str_split(tolower(descriptionText), " "),
#     type,
#     typeId,
#     moduleId
# )

# infection_descriptions <- infection_concepts$descriptions %>%
#   dplyr::bind_rows() %>%
#   dplyr::filter(active, type != "FSN") %>%
#   dplyr::transmute(
#     conceptId,
#     descriptionId,
#     descriptionText = term
# ) %>% 
#   tidytext::unnest_tokens(output = snomed_tokens, input = descriptionText)
# 
# head(infection_descriptions)
```


The range of tokens is examined to identify **stop words**, that is, common words that can be eliminated, for instance prepositions. Stop words must be eliminated because they are not essential or characteristic components of a clinical term and thus make it more difficult to effectively map terminology. We also eliminate the words `"caused"` and `"due"`.


```{r remove_snomed_stop_words}

# infection_descriptions <- infection_descriptions %>% 
#   filter(!snomed_tokens %in% stopwords::stopwords(language = "en")) %>% 
#   filter(!snomed_tokens %in% c("caused", "due"))
# 
# infection_descriptions %>% 
#   group_by(snomed_tokens) %>% 
#   summarise(n = n()) %>% arrange(-n) %>% 
#   head(15)
# snomed_unique_tokens <- tibble(
#   tokens = unlist(infection_descriptions$tokens_concept)
#   ) %>%
#   group_by(tokens) %>%
#   summarise(n = n()) %>%
#   arrange(-n)
# 
# head(snomed_unique_tokens, 10)
```

The data frame is then condensed to have one row per `descriptionId` once again. It is now ready to be used.

```{r condense_infection_descriptions}
# infection_descriptions <-  infection_descriptions %>%  
#   group_by(conceptId, descriptionId) %>% 
#   summarise(snomed_tokens = list(snomed_tokens))
# 
# str(infection_descriptions, max.level = 1)
```


## Processing antibiotic prescription indication stricts

The `drug_indications` dataset contains free text that was manually inputted by clinicians. Due to this, it requires more extensive cleaning than SNOMED CT concept descriptions. A new variable `indication_string` is generated for conversion to lowercase, punctuation cleaning and removal of add hoc concepts. This is particularly the case with information that does not map to SNOMED CT concepts, which must be extracted manually. In this case, prescriptions issued according to advice provided by a microbiologist are often marked with short formulae such as `"as per micro"` or `"d/w micro"` (discussed with microbiology).

```{r clean_drug_indications}
# as_per_micro_pattern <- "(as per micro)|(d/w micro)|(micro advice)|(discussed with micro)|(micro approved)|(on advice of micro)"
# 
# drug_indications <- drug_indications %>%
#   mutate(indication_string = str_remove(tolower(indication), "[?]")) %>%
#   mutate(indication_string = trimws(str_replace_all(indication_string, "( )+|[(),]+", " "))) %>%
#   mutate(as_per_micro = grepl(as_per_micro_pattern, indication_string)) %>% 
#   mutate(indication_string = gsub(as_per_micro_pattern, "", indication_string)) %>% 
#   mutate(freetext_tokens = stringr::str_split(indication_string, 
#                                               pattern = "( )|(/)"))
# 
# head(drug_indications, 10)
```

```{r clean_drug_indications_tokens}

# drug_indications <- drug_indications %>% 
#   mutate(freetext_tokens = purrr::map(freetext_tokens, function(x) {
#     x[x == "uti"] <- "urinary tract infection"
#     x[x == "hap"] <- "hospital acquired pneumonia"
#     x[x == "cap"] <- "community acquired pneumonia"
#     x[x == "cdi"] <- "clostridium difficile infection"
#     x[x == "cdiff"] <- "clostridium difficile infection"
#     x[x == "lrti"] <- "lower respiratory tract infection"
#     x[x == "rti"] <- "respiratory tract infection"
#     x[x == "iv"] <- "intravenous"
#     x[x == "csf"] <- "cerebrospinal fluid"
#     x[x == "abx"] <- "antibiotic"
#     x[x == "msu"] <- "mid stream urine"
#     x[x == "resp"] <- "respiratory"
#     x[x == "copd"] <- "chronic obstructive pulmonary disease"
#     x[x == "xcopd"] <- "chronic obstructive pulmonary disease acute exacerbation"
#     x[x == "infn"] <- "infection"
#     x[x == "ae"] <- "acute exacerbation"
#     x[x == "abdo"] <- "abdominal"
#     x[x == "intra-abdo"] <- "intra-abdominal"
#     x[x == "sbp"] <- "spontaneous bacterial peritonitis "
#     x <- x[!grepl("^[[:punct:]]$", x)] 
#     x <- gsub("(^[[:punct:]])|([[:punct:]]$)", "", x)
#     
#     x <- unlist(str_split(x, " ") )
#     x <- x[!x %in% stopwords::stopwords(language = "en")]
#     x <- x[!x %in% c("", "due", "caused")] 
#     x
#   }))
# unique(unlist(drug_indications$freetext_tokens))
# unique_tokens <- tibble(tokens = unlist(rx_indications$tokens_src)) %>%
#   group_by(tokens) %>%
#   summarise(n = n()) %>%
#   arrange(-n)
# 
 
```


## Mapping SNOMED CT concepts

blah
```{r}
# concept_mapping <- tidyr::crossing(drug_indications, 
#                                    infection_descriptions) %>% 
#   mutate(overlap = purrr::map2_lgl(
#     freetext_tokens, 
#     snomed_tokens, 
#     function(source, concept) {
#     all(concept %in% source)
#   })) %>% 
#   filter(overlap) %>% 
#   distinct(prescription_id, conceptId) 

# drug_indications %>% 
#   select(prescription_id, indication) %>% 
#   left_join(concept_mapping) %>% 
#   left_join(select(infection_concepts, conceptId, pt.term))

# concept_mapping <- mutate(
#   concept_mapping,
#   overlap_tot = purrr::map2_int(freetext_tokens, snomed_tokens, function(source, concept) {
#     sum(concept %in% source)
#   }),
#   overlap_pct = purrr::map2_dbl(freetext_tokens, snomed_tokens, function(source, concept) {
#     sum(concept %in% source)/length(concept)
#   })) %>% 
#   arrange(prescription_id, -overlap_pct)
# 
# concept_mapping %>%
#   filter(overlap_pct > .5)  %>% 
#   arrange(prescription_id, -overlap_pct) %>% 
#    View()
# 
# concept_mapping  %>% group_by(indication) %>%
#   arrange(-overlap_pct, -overlap_tot) %>%
#   mutate(rank= 1:n()) %>%
#   filter(rank <= 5) %>%
#   ungroup() %>%
#   View()
```
 


```{css, echo=FALSE }

body {
   # font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  line-height: 1.4em;
  font-size: 16px
}

#   
# .note {
#   padding: 1em 1em 1em 4em;
#   margin-bottom: 10px;
#   background: #f5f5f5 5px center/3em no-repeat;
# }

.bd-callout {
  padding: 1.5em;
  margin-top: 2em;
  margin-bottom: 2em;
  border: 1px solid #eee;
  border-left-width: .25rem;
  border-radius: .25rem;
}

.bd-callout h4, h3 {
  padding-top: 0;
  margin-top: 0;
  margin-bottom: .25rem;
}
 
.bd-callout p:last-child {
  margin-bottom: 0;
}

.bd-callout code {
  border-radius: .25rem;
}

.bd-callout + .bd-callout {
  margin-top: -.25rem;
}

.bd-callout-info {
  border-left-color: #5bc0de;
}

# .bd-callout-info h4 {
#   color: #5bc0de;
# }

.bd-callout-warning {
  border-left-color: #f0ad4e;
}

# .bd-callout-warning h4 {
#   color: #f0ad4e;
# }

.bd-callout-danger {
  border-left-color: #d9534f;
}

# .bd-callout-danger h4 {
#   color: #d9534f;
# }

.bd-examples .img-thumbnail {
  margin-bottom: .75rem;
}

.bd-examples h4 {
  margin-bottom: .25rem;
}

.bd-examples p {
  margin-bottom: 1.25rem;
}
```
