% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rest-api.R
\name{api_operations}
\alias{api_operations}
\alias{api_concept}
\alias{api_concepts}
\alias{api_concept_descendants}
\alias{api_concept_descriptions}
\alias{api_all_branches}
\alias{api_branch}
\alias{api_branch_descendants}
\alias{api_descriptions}
\alias{api_version}
\alias{api_browser_concepts}
\alias{api_browser_concept_ancestors}
\alias{api_browser_concept_children}
\alias{api_browser_concept_parents}
\alias{api_browser_concept_descriptions}
\alias{api_descriptions_semantic_tags}
\alias{api_relationships}
\alias{api_relationship}
\alias{api_all_code_systems}
\alias{api_code_system}
\alias{api_code_system_all_versions}
\alias{api_browser_refset_members}
\alias{api_refset_members}
\title{SNOMED CT Terminology Server REST API operations}
\usage{
api_concept(
  conceptId,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_concepts(
  term = NULL,
  conceptIds = NULL,
  ecl = NULL,
  eclStated = NULL,
  activeFilter = NULL,
  searchAfter = NULL,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  limit = snomedizer_options_get("limit"),
  offset = 0,
  catch404 = TRUE,
  ...
)

api_concept_descendants(
  conceptId,
  stated = FALSE,
  limit = snomedizer_options_get("limit"),
  offset = 0,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_concept_descriptions(
  conceptId,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_all_branches(
  endpoint = snomedizer_options_get("endpoint"),
  catch404 = TRUE
)

api_branch(
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE,
  ...
)

api_branch_descendants(
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE,
  ...
)

api_descriptions(
  conceptIds = NULL,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  offset = 0,
  limit = snomedizer_options_get("limit"),
  catch404 = TRUE,
  ...
)

api_version(endpoint = snomedizer_options_get("endpoint"), catch404 = TRUE)

api_browser_concepts(
  conceptId,
  descendantCountForm = c(NULL, "inferred", "stated", "additional"),
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_browser_concept_ancestors(
  conceptId,
  form = "inferred",
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_browser_concept_children(
  conceptId,
  form = "inferred",
  includeDescendantCount = TRUE,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_browser_concept_parents(
  conceptId,
  form = "inferred",
  includeDescendantCount = TRUE,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_browser_concept_descriptions(
  term,
  active = NULL,
  module = NULL,
  language = NULL,
  type = NULL,
  semanticTag = NULL,
  semanticTags = NULL,
  preferredIn = NULL,
  acceptableIn = NULL,
  preferredOrAcceptableIn = NULL,
  conceptActive = NULL,
  conceptRefset = NULL,
  groupByConcept = FALSE,
  searchMode = "STANDARD",
  limit = snomedizer_options_get("limit"),
  offset = 0,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_descriptions_semantic_tags(
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  catch404 = TRUE
)

api_relationships(
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  active = NULL,
  source = NULL,
  type = NULL,
  destination = NULL,
  characteristicType = NULL,
  limit = snomedizer_options_get("limit"),
  offset = 0,
  catch404 = TRUE,
  ...
)

api_relationship(
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  relationshipId,
  catch404 = TRUE,
  ...
)

api_all_code_systems(
  endpoint = snomedizer_options_get("endpoint"),
  forBranch = NULL,
  catch404 = TRUE
)

api_code_system(
  endpoint = snomedizer_options_get("endpoint"),
  shortName,
  catch404 = TRUE
)

api_code_system_all_versions(
  endpoint = snomedizer_options_get("endpoint"),
  shortName,
  showFutureVersions = FALSE,
  showInternalReleases = FALSE,
  catch404 = TRUE
)

api_browser_refset_members(
  referenceSet = NULL,
  referenceSetModule = NULL,
  referencedComponentId = NULL,
  active = NULL,
  offset = NULL,
  searchAfter = NULL,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  limit = snomedizer_options_get("limit"),
  catch404 = TRUE
)

api_refset_members(
  referenceSet = NULL,
  referenceSetModule = NULL,
  referencedComponentId = NULL,
  active = NULL,
  offset = NULL,
  searchAfter = NULL,
  targetComponent = NULL,
  mapTarget = NULL,
  owlExpression.conceptId = NULL,
  owlExpression.gci = NULL,
  endpoint = snomedizer_options_get("endpoint"),
  branch = snomedizer_options_get("branch"),
  limit = snomedizer_options_get("limit"),
  catch404 = TRUE
)
}
\arguments{
\item{conceptId}{character string of a SNOMED CT concept identifier (for example:
\code{"233604007"})}

\item{endpoint}{URL of a SNOMED CT Terminology Server REST API endpoint.
See \code{\link{snomedizer_options}}.}

\item{branch}{a string for the name of the API endpoint branch to use (most
commonly \code{"MAIN"}). See \code{\link{snomedizer_options}}.}

\item{catch404}{whether to display a warning if the API operation returns a
'404 Not Found' status. Default is \code{TRUE}.}

\item{term}{character vector of terms to search}

\item{conceptIds}{a character vector of SNOMED CT concept identifiers (for example:
\code{c("233604007", "68566005")})}

\item{ecl}{a character expression constraint query (with full relationship inference).
Consult the \href{http://snomed.org/ecl}{Expression Constraint Language guide}
for more detail.}

\item{eclStated}{a character expression constraint query (limited to stated relationships).
Consult the \href{http://snomed.org/ecl}{Expression Constraint Language guide}
for more detail.}

\item{activeFilter}{optional boolean: \itemize{
    \item \code{TRUE} returns only active terminology
    \item \code{FALSE} returns only inactive terminology
    \item \code{NULL} (the default) returns both active and inactive terminology
}}

\item{searchAfter}{integer for the number of results to skip. May be used for
for querying more that 10,000 records (current \code{limit} on results returned)}

\item{limit}{a positive integer for the maximum number of results to return.
See \code{\link{snomedizer_options}}. The maximum limit on public endpoints
is 10,000.}

\item{offset}{an integer indicating the number of results to skip}

\item{...}{other REST API parameters}

\item{stated}{a boolean indicating whether to limit search to descendants
whose relationship is stated rather than inferred. Default is \code{FALSE}.}

\item{descendantCountForm}{a character string indicating whether to report
the count of descendant concepts based on stated or inferred relationships.
Must be one of \code{"inferred"}, \code{"stated"}, or \code{"additional"}.
Default is \code{NULL} for no descendant count reported.}

\item{form}{a character string indicating which ancestors/parents or
descendants/children to extract based on stated or inferred relationships.
Must be one of \code{"inferred"} (default), \code{"stated"}, or \code{"additional"}.}

\item{includeDescendantCount}{a boolean indicating whether a number of
children/descendants counter should be included in the result}

\item{active}{optional boolean: \itemize{
    \item \code{TRUE} returns only active terminology
    \item \code{FALSE} returns only inactive terminology
    \item \code{NULL} (the default) returns both active and inactive terminology
}}

\item{module}{character vector of SNOMED CT modules to include (example:
\code{"900000000000207008"})}

\item{language}{vector of two-character language codes to include
(example: \code{c("en", "de")}).}

\item{type}{character vector of concept codes defining the type of description or
the type of attribute/relationship to include, depending on the function:
\itemize{
   \item see \code{api_concept_descendants("900000000000446008")} for valid
   description type concepts.
   \item see \code{api_concept_descendants("106237007")} for valid
   attributes (relationship types) concepts.
 }}

\item{semanticTag}{character string of a description semantic tag
to include (example: \code{"attribute"}). See
\code{api_descriptions_semantic_tags()} for a list of valid
description semantic tags.}

\item{semanticTags}{character vector of description semantic tags
to include (example: \code{c("attribute", "finding")}). See
\code{api_descriptions_semantic_tags()} for a list of valid
description semantic tags.}

\item{preferredIn}{character vector of description language reference sets
(example: \code{"900000000000509007"}).
The description must be preferred in at least one of these to match.}

\item{acceptableIn}{character vector of description language reference sets
(example: \code{"900000000000509007"}).
The description must be acceptable in at least one of these to match.}

\item{preferredOrAcceptableIn}{character vector of description language reference sets
(example: \code{"900000000000509007"}).
The description must be preferred OR acceptable in at least one of these to match.}

\item{conceptActive}{optional boolean: \itemize{
    \item \code{TRUE} returns only active concepts
    \item \code{FALSE} returns only inactive concepts
    \item \code{NULL} (the default) returns both active and inactive concepts
}}

\item{conceptRefset}{character vector of reference sets concept identifiers
to include (example: \code{"900000000000497000"} for CTV3 terminology).
See \code{api_concept_descendants("900000000000455006")}
for valid reference set concepts.}

\item{groupByConcept}{a boolean indicating whether to group descriptions
by concept. Default is \code{FALSE}.}

\item{searchMode}{a character string for the search mode. Must be either
\code{"STANDARD"} (default) or \code{"REGEX"}.}

\item{source}{a character vector of concepts to be included as
sources defined by the relationship}

\item{destination}{concept character string restricting the range of the
relationships to be included in results}

\item{characteristicType}{a character string indicating whether to include
results for: \itemize{
    \item all relationships: NULL (the default)
    \item only stated relationships: "STATED_RELATIONSHIP"
    \item only inferred relationships: "INFERRED_RELATIONSHIP"
    \item only additional relationships: ""ADDITIONAL_RELATIONSHIP" (for
    instance, \code{123005000 | Part of (attribute) |})
}
This parameter corresponds to \code{
900000000000449001 | Characteristic type (core metadata concept)}}

\item{relationshipId}{string of a relationship concept}

\item{forBranch}{a character name of a single branch (eg \code{"MAIN"}) for which
to fetch code systems results. The default (\code{NULL}) will return all code systems.}

\item{shortName}{character name of a code system (eg \code{"SNOMEDCT"},
\code{"SNOMEDCT-UK"})}

\item{showFutureVersions}{a boolean indicating whether to include all code
systems (\code{NULL}), only future code systems (\code{TRUE}),
or no future code systems (\code{FALSE}, the default)}

\item{showInternalReleases}{a boolean indicating whether to include all
terminology releases (\code{NULL}), only internal releases (\code{TRUE}), or
only external releases (\code{FALSE}, the default)}

\item{referenceSet}{a string for a reference set identifier or ECL expression
can be used to limit the reference sets searched. Example: \code{"<723564002"}}

\item{referenceSetModule}{a string identifier for a SNOMED CT module containing
the reference sets to include. An ECL expression can be used to limit
the modules searched, for example: \code{"<900000000000445007"}}

\item{referencedComponentId}{a character vector of identifiers of
SNOMED CT components to be included. For Map Reference Sets, this refers
to the SNOMED CT concept that is mapped to the other terminology or code system}

\item{targetComponent}{string identifier the target code
(concept or description) in an Association Reference Set. Consult the
\href{https://confluence.ihtsdotools.org/display/DOCRELFMT/5.2.5+Association+Reference+Set}{Association Reference Set data structure}
for detail.}

\item{mapTarget}{target code to which the SNOMED CT concept represented the
\code{referencedComponentId} is mapped in the target code system, classification,
or terminology (eg ICD-10). This is only used for Map Reference Sets}

\item{owlExpression.conceptId}{a string for a concept identifier within an
owlExpression. Consult the
\href{http://snomed.org/owl}{SNOMED CT OWL Guide} for detail.}

\item{owlExpression.gci}{a boolean indicating whether to return axiom members
with a GCI owlExpression (\code{TRUE}), without (\code{FALSE}), or all members
(\code{NULL}, the default). Consult the
\href{http://snomed.org/owl}{SNOMED CT OWL Guide} for detail.}
}
\value{
An \code{httr} \code{\link[httr]{response}()} object.
}
\description{
Low-level wrapper functions based on \link{httr} for interfacing
with the operations built in the \href{https://github.com/IHTSDO/snowstorm}{Snowstorm API}
}
\section{Disclaimer}{

In order to use SNOMED CT, a licence is required which depends both on the country you are
based in, and the purpose of your work. See details on \link{snomedizer}.
}

\examples{
# look up the pneumonia concept
api_concept(conceptId = "233604007")
api_concepts(term = "pneumonia")
api_concepts(conceptIds = c("233604007", "68566005"))

# get the content of the server request
pneumonia <- httr::content(api_concepts(term = "pneumonia"), limit = 1)
str(pneumonia$items[[1]])
}
\concept{api_operations}
